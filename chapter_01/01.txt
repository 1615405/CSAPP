一. 信息就是位 + 上下文
    1. 像 hello.c 这样只由 ASCII 字符构成的文件称为文本文件，所有其他文件都称为二进制文件。
    2. 系统中所有的信息————包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。
区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示为一个整数，
浮点数，字符串或者机器指令。


二. 程序被其他程序翻译成不同的格式
    1. GCC编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，
执行这四个阶段的程序(预处理器，编译器，汇编器和链接器)一起构成了编译系统。
        预处理阶段：预处理器(cpp)根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第一行的 #include <stdio.h> 命令
    告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常以 .i 作为文件扩展名。
        编译阶段：编译器(cc1)将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。
        汇编阶段：汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件
    hello.o 中。
        链接阶段：hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 
    printf.o 的单独的预编译好的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器(ld)就负责这种合并。结果就
    得到 hello 文件，它是一个可执行目标文件(或者简称为可执行文件)，可以被加载到内存中，由系统执行。


三. 了解编译系统如何工作是大有益处的
    1. 优化程序性能
    2. 理解链接时出现的错误
    3. 避免安全漏洞


四. 处理器读并解释储存在内存中的指令
    1. shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的
shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。
    2. 系统的硬件组成
        总线：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，
    也就是字。字中的字节数(即字长)是一个基本的系统参数，各个系统中都不尽相同。
        I/O设备：I/O(输入/输出)设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器
    之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印刷电路板(主板)上的芯片组。而适配器则是一块插在主板插槽上的
    卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。
        主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上说，主存是由一组动态随机存取存储器
    (DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。
    一般来说，组成程序的每条机器指令都由不同数量的字节组成。
        处理器：中央处理单元(CPU)，简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备
    (或寄存器)，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。
        利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。
        一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将
    "hello, world\n" 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。


五. 高速缓存至关重要
    L1 和 L2 高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。比较新的，处理能力更强大的系统甚至有三级高速缓存，
L1,L2和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码
的趋势。


六. 存储设备形成层次结构
    存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存
，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他
系统磁盘上的数据的高速缓存。


七. 操作系统管理硬件
    1. 所有应用程序对硬件的操作尝试都必须通过操作系统。
    2. 操作系统有两个基本功能：
        (1) 防止硬件被失控的应用程序滥用
        (2) 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。
        操作系统通过几个基本的抽象概念(进程，虚拟内存和文件)来实现这两个功能。文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O
    设备的抽象表示，进程则是对处理器，内存和I/O设备的抽象表示。

    3. 像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器，
主存和I/O设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。
    4. 进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程。而每个进程都好像在独占地使用硬件。而并发运行，
则是说一个进程的指令和另一个进程的指令是交错执行的。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过
处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。
    5. 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容
。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即
保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。
    6. 从一个进程到另一个进程的切换是由操作系统内核(kernel)管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些
操作时，比如读写文件，它就执行一条特殊的系统调用(system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。
内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

    7. 一个进程实际上可以由多个被称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

    8. 虚拟内存
        (1) 虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为
    虚拟地址空间。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放
    用户进程定义的代码和数据。
        (2) 程序代码和数据：对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接
    按照可执行目标文件的内容初始化的。
        (3) 堆：代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free
    这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。
        (4) 共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。
        (5) 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。
    特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。
        (6) 内核虚拟内存：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，
    它们必须调用内核来执行这些操作。
        虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存
    的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

    9. 文件就是字节序列，仅此而已。每个I/O设备，包括磁盘，键盘，显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过
    使用一小组称为Unix I/O的系统函数调用读写文件来实现的。